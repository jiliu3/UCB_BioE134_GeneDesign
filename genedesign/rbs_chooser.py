from dataclasses import dataclass

from genedesign.models.rbs_option import RBSOption

# -*- coding: utf-8 -*-
"""Copy of BioE134/234_RBSChooser_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o3zZJIKwMXrcvf1PzIuvj_4GooaORq4U
"""

from typing import Set


@dataclass
class Translate:
    """
    Translates a DNA sequence into a protein sequence using the standard genetic code, halting at the first stop codon encountered and throwing an error for invalid codons.

    Attributes:
        codon_table (dict): Maps each DNA codon to its corresponding single-letter amino acid code.
    """
    codon_table: dict = None

    def initiate(self) -> None:
        """
        Initializes the codon table with the genetic code for translating nucleotide triplets into amino acids.
        """
        self.codon_table = {
            "TTT": "F", "TTC": "F", "TTA": "L", "TTG": "L",
            "CTT": "L", "CTC": "L", "CTA": "L", "CTG": "L",
            "ATT": "I", "ATC": "I", "ATA": "I", "ATG": "M",
            "GTT": "V", "GTC": "V", "GTA": "V", "GTG": "V",
            "TCT": "S", "TCC": "S", "TCA": "S", "TCG": "S",
            "CCT": "P", "CCC": "P", "CCA": "P", "CCG": "P",
            "ACT": "T", "ACC": "T", "ACA": "T", "ACG": "T",
            "GCT": "A", "GCC": "A", "GCA": "A", "GCG": "A",
            "TAT": "Y", "TAC": "Y", "TAA": "Stop", "TAG": "Stop",
            "CAT": "H", "CAC": "H", "CAA": "Q", "CAG": "Q",
            "AAT": "N", "AAC": "N", "AAA": "K", "AAG": "K",
            "GAT": "D", "GAC": "D", "GAA": "E", "GAG": "E",
            "TGT": "C", "TGC": "C", "TGA": "Stop", "TGG": "W",
            "CGT": "R", "CGC": "R", "CGA": "R", "CGG": "R",
            "AGT": "S", "AGC": "S", "AGA": "R", "AGG": "R",
            "GGT": "G", "GGC": "G", "GGA": "G", "GGG": "G"
        }

    def run(self, dna_sequence: str) -> str:
        """
        Translates a DNA sequence into a protein sequence using the codon table.

        Parameters:
            dna_sequence (str): The DNA sequence to translate.

        Returns:
            str: The corresponding amino acid sequence.

        Raises:
            ValueError: If the DNA sequence length is not a multiple of three, contains untranslated sequence after a stop codon, or contains invalid codons.
        """
        if len(dna_sequence) % 3 != 0:
            raise ValueError("The DNA sequence length must be a multiple of 3.")

        protein = []
        for i in range(0, len(dna_sequence), 3):
            codon = dna_sequence[i:i+3]
            if codon not in self.codon_table:
                raise ValueError(f"Invalid codon '{codon}' encountered in DNA sequence.")
            amino_acid = self.codon_table[codon]
            if amino_acid == "Stop":
                if i + 3 != len(dna_sequence):
                    raise ValueError("Untranslated sequence after stop codon.")
                break
            protein.append(amino_acid)

        return ''.join(protein)

"""# Selection of Ribosome Binding Sites (RBS)
This project guides you through the synthetic biology challenge of selecting an RBS that effectively expresses a foreign gene. Utilizing raw experimental data and AI assistance, you will learn to create an RBSChooser function that processes genetic data to predict well-expressing transcripts.

### Learning Objectives
* Understand synthetic biology principles related to RBS functionality.
* Learn to tackle genomics and proteomics problems.
* Utilize ChatGPT for coding assistance and script refinement.
* Apply the function-as-object pattern for efficient data preprocessing.
* Engage in a multi-objective optimization problem.

### Using AI
ChatGPT-4o is available for free; you can log in with your Berkeley email or a personal account. It's recommended to conduct the entire assignment within a single chat session with ChatGPT-4o to maintain a streamlined workflow. You may also be successful with Gemini, Claude, or Llama models, but I have not tried. If anything in this project is unclear to you, try asking the AI to explain it.  If you still need help, come to office hours.

***Make a copy of this notebook, complete the 'todos' in this document, then download it as a .ipynb file and submit that file to bcourses.***

# Implementing initiate

The central insights behind our implementation of RBSChooser are:

1.   Naturally occuring 5' UTR sequences are evolutionarily optimized to 'work'
2.   Proteomics data can empirically define 'strongly expressing genes'
3.   The primary (known) source of failure can be anticipated with secondary structure prediction algorithms

For this approach, we will need experimental data containing gene sequences from which we can mine our UTR sequences, as well as a proteomics data set for the same strain.  For this, we'll use the original *E. coli* K12 isolate MG1655.

## Download the source data
The proteomics dataset was found by browsing the PAX-db website and clicking the download button: https://pax-db.org/dataset/511145/2297923011. I also downloaded the genome sequence for MG1655 from https://www.ncbi.nlm.nih.gov/nuccore/U00096.2. I found these resources through google searches.

I uploaded the two files to Google Drive. In the block below, I download both files from the drive into Colab.
"""

# Install gdown if not already installed


# URLs of the files to download
file_urls = [
    '1BSvQQVN0J_A1_ONZ5ioGrfJoF9Yv_Hwl',
    '1oCCu8AsAiJAKa3_nOI2y-iv_h6wb5-JI'
]

# Download the files


"""## Process raw data

The rest of this we'll do with ChatGPT. The AI often won't get the code right on the first try, and it is an iterative process to get working code.  For intricate and long tasks, it is helpful to break the task into smaller pieces. You can get all the elements functional and then later ask the AI to combine them together into one complete program.

For any Function, we can break it into the two phases:  initiate and run, so that is a natural place to divide up the coding task.  During run, RBSChooser will select amongst a list of options (RBSOption instances).  That list will be populated during initiate and stored as a class variable such that it is cached.  We can then confirm we are done writing initiate by inspecting the class variables before moving on to run.

Within the initiate method, we can break things down further to:

1.   Read and extract the relevant gene data
2.   Prune the proteomics data to just the top 5%
3.   Merge the two data sets
4.   Create instances of RBSOption and store in class variables

I've prompted ChatGPT to do step 1 for us. The chat is here:
https://chatgpt.com/share/fd4b01fa-cbd6-4f21-954c-8af739112889

In this chat, the most important statement is "I want a colab script that will extract the locus_tag="b0001", gene="thrL", the 5' UTR, and the cds."  That is the instruction.  It doesn't matter if the instruction is in the middle or beginning or end of the prompt; what matters is that there is a clear statement of what form you want the AI to respond with and that you express it as clearly and precisely (and correctly) as possible.

The rest of the prompt is context, examples, constraints, and hints.  I dug up part of the file text so it knew the form it took and could clearly identify it as genbank.  I also wanted it to see the annotation data, since that is not standardized by genbank, and it will need to know the field names present.

I mention the 'complementary' issue because on a previous attempt the algorithm failed to take into account that edge case.

I also describe the specific type of the output I want as I am anticipating the next steps which will need this format.  If I didn't say precisely what I wanted, I would probably get a simple list.

The chat then goes through several cycles of copying and pasting the AI-generated code into colab, running it, and copying and pasting back in the output.  In some cases, I could readily see what was wrong with it and gave it a helpful hint.  In many cases this is not necessary and just replying with the output is sufficient to eventually solve the task.  Often the problem relates to an incorrect guess for the syntax of a service or library. In such cases, downloading the API documentation and showing it to the LLM will get it back on course.  Sometimes suggesting it put in some print statements helps.

Notice I made a typo in my original prompt saying sequence.db instead of sequence.gb. Though .gb is a standard file extension for this type of data, which GPT-4o certainly knows, it left it as db until I corrected it near the end.  What you should take from this is that whatever you say to GPT it will accept as truth, or perhaps more accurately it postulates it as a truth within the scope of the chat. So, if you tell it something false, it will premise the rest of the conversation on that falsehood.  Where things get really problematic is when you tell it inconsistant things, conflicting things, or confusing statements.
"""

# Install Biopython if not already installed (if needed, this can be skipped since Biopython is already installed)
# !pip install biopython

from Bio import SeqIO
from collections import defaultdict

# Function to extract UTR, gene, and CDS information from the GenBank file
def extract_genes_info(genbank_file):
    gene_dict = defaultdict(dict)  # Dictionary to store gene info
    for record in SeqIO.parse(genbank_file, "genbank"):
        for feature in record.features:
            if feature.type == "gene":
                locus_tag = feature.qualifiers.get("locus_tag", [None])[0]
                gene_name = feature.qualifiers.get("gene", [None])[0]

                # CDS information
                cds_feature = None
                for cds in record.features:
                    if cds.type == "CDS" and cds.qualifiers.get("locus_tag") == [locus_tag]:
                        cds_feature = cds
                        break

                if cds_feature:
                    start, end = cds_feature.location.start, cds_feature.location.end
                    strand = cds_feature.location.strand
                    if strand == 1:  # Forward strand
                        utr_start = max(0, start - 50)
                        utr_seq = record.seq[utr_start:start]
                    else:  # Reverse strand, we need to reverse complement
                        utr_start = end
                        utr_seq = record.seq[utr_start:utr_start + 50].reverse_complement()

                    cds_seq = cds_feature.extract(record.seq)
                    # Save the gene information in the dictionary
                    gene_dict[locus_tag] = {
                        "gene": gene_name,
                        "UTR": utr_seq,
                        "CDS": cds_seq
                    }
    return gene_dict

# Example usage
genbank_file = "genedesign\data\sequence.gb"  # Now using the correct file name
genes_info = extract_genes_info(genbank_file)
##print(genes_info)
"""
# Display the first 10 extracted entries
for idx, (locus_tag, gene_info) in enumerate(genes_info.items()):
    print(f"Locus Tag: {locus_tag}")
    print(f"Gene Name: {gene_info['gene']}")
    print(f"UTR: {gene_info['UTR']}")
    print(f"CDS: {gene_info['CDS']}")
    print("-" * 40)

    if idx == 9:  # Stop after printing 10 entries
        break
"""

"""### Prune to 5%
Next, download and drag/drop the proteomics data on the chat. Put in a prompt describing pruning the proteomics data and returning a list of locus tag:abundance pairs.  Run the result below.  

You can confirm the correctness by inspection:
*  There will be 5% of the number of lines in the data relative to the original file
*  Browsing the data file you will get an idea for higher and lower numbers.  You can check that the top 5% extracted all have high numbers.
*  Along those lines, you could sort the dataset in Excel and then look for the top few candidates in the pruned list.
* Your output should look something like:


```
b3495: 45935.0
b3986: 12183.0
b3339: 10296.0
b1779: 8675.0
```


"""

import pandas as pd

# Load the TSV file into a pandas dataframe
df = pd.read_csv("genedesign\data\\511145-WHOLE_ORGANISM-integrated.tsv", sep='\t')

# Clean the column name (remove the # character)
df.columns = ['locus_tag', 'abundance']

# Convert the abundance column to numeric (just in case)
df['abundance'] = pd.to_numeric(df['abundance'], errors='coerce')

# Drop rows with missing abundance values
df = df.dropna(subset=['abundance'])

# Sort the dataframe by abundance in descending order
df_sorted = df.sort_values(by='abundance', ascending=False)

# Calculate the top 5% threshold
top_5_percent_cutoff = int(len(df_sorted) * 0.05)

# Select the top 5% entries
top_5_percent_df = df_sorted.head(top_5_percent_cutoff)

# Extract the locus tag and abundance pairs
top_5_percent_list = list(top_5_percent_df[['locus_tag', 'abundance']].itertuples(index=False, name=None))

# Output the result
top_5_percent_list[:10], len(top_5_percent_list)  # Show the first 10 entries and the total count

"""### Merge the data
Write a prompt to create a new dictionary where the key is the locus tag, and the value is that extracted rbs/cds data.  Only include those top 5%.

You can confirm the correctness by examining the number of entries and confirming the presence of the high-expressing loci.
"""

from re import L
# Assuming 'top_5_percent_list' is a list of tuples, where the first element is the locus_tag

# Initialize the final merged dictionary
final_dict = {}

# Iterate over the list and merge with genes_info
for entry in top_5_percent_list:
    locus_tag = entry[0][7:]  # Assuming the first element is the locus_tag

    # Check if the locus_tag exists in genes_info
    if locus_tag in genes_info:
        # Merge the UTR and CDS info from genes_info with the entry
        final_dict[locus_tag] = {
            "gene": genes_info[locus_tag]['gene'],
            "UTR": genes_info[locus_tag]["UTR"],
            "CDS": genes_info[locus_tag]["CDS"]
        }
#print(len(final_dict))
"""
i = 0
# Example: Print the merged dictionary
for locus_tag, data in final_dict.items():
    print(f"Locus Tag: {locus_tag}")
    print(f"gene: {data['gene']}")
    print(f"UTR: {data['UTR']}")
    print(f"CDS: {data['CDS']}")
    print("-" * 40)
    i += 1
    if i == 10:
        break
"""
"""### Store RBSOption
Our last step is to construct instances of RBSOption and store them in a list as a class variable.  For this, we need to first define the structure of the RBSOptions, and for that we need to consider what our run method will need both to operate as well as facilitate debugging.

*  We certainly will need the 5' UTR sequences.  We might called field "utr" or "rbs", but utr is more specific and won't conflict with calling the full object rbs as well as a subfield being 'rbs'.

*  For purposes of debugging and testing, it will be helpful to retain the name and the CDS sequence in RBSOption

*  Our algorithm will also be comparing the first 6 amino acids of the source gene's protein sequence to that of the input CDS (the one we are choosing an RBS for).  It will prioritize shorter distances.  For this, it will make our algorithm more efficient if we precalculate these 6 aa strings for each gene and store them in the class objects. We can define RBSOption now as an immutable dataclass:
"""

@dataclass(frozen=True)
class RBSOption:
    """
    Encapsulates Ribosome Binding Site (RBS) encoding DNAs as modular components (parts) for synthetic biology,
    representing essential sequence elements to facilitate selection algorithms.

    Attributes:
        utr (str): The 5' untranslated region (5' UTR) sequence
        cds (str): The coding sequence of the source gene
        gene_name (str): The name of the source gene
        first_six_aas (str): The precalculated first six amino acids of the source gene's protein sequence
    """
    utr: str
    cds: str
    gene_name: str
    first_six_aas: str

"""We previously constructed a map that takes us from the locus tag of each 5%-best gene to the rbs and cds sequences.  You need to write a prompt explaining how to construct an instance of RBSOption for each of those genes in the dictionary filling in the additional first_six_aas field as you go.  For that, you will need a Translate function that can handle the conversion of the source gene's cds's first 18 bases to 6 aas.

"""

from dataclasses import dataclass

# Example usage:
"""
translator = Translate()
translator.initiate()
protein_sequence = translator.run("ATGCGACGTTAA")
print("Protein sequence:", protein_sequence)
"""
"""Implement the RBSChooser class.  You can leave the run method empty for now, but you should get the initiate method fully defined and working.  You should include a test example and iterate on it until the resulting instance of RBSChooser has its class variable correctly populated.."""

from typing import Set

class RBSChooser:
    def __init__(self):
        self.rbs_options = []  # To store RBSOption instances
        self.translator = Translate()
        self.translator.initiate()  # Initialize the translator

    def initiate(self):
        # Iterate over the final_dict and create RBSOption instances
        for locus_tag, data in final_dict.items():
            utr = data["UTR"]
            cds = data["CDS"]
            gene_name = locus_tag  # Using locus_tag as gene_name

            # Translate the CDS to get the first six amino acids
            protein_sequence = self.translator.run(cds[:18])
            first_six_aas = protein_sequence  # Get the first six amino acids

            # Create an RBSOption instance
            rbs_option = RBSOption(utr=utr, cds=cds, gene_name=gene_name, first_six_aas=first_six_aas)

            # Add the RBSOption to the list
            self.rbs_options.append(rbs_option)

    def get_rbs_options(self):
        return self.rbs_options

    def run(self, cds: str, ignores: Set[RBSOption]) -> RBSOption:
        pass  # Placeholder, no implementation needed right now

# Instantiate RBSChooser and initiate
chooser = RBSChooser()
chooser.initiate()

# Print out the first 5 RBS Options stored in the class variables
# TODO:  examine the the class variables
"""
for i in range(5):
    rbs_options = chooser.get_rbs_options()
    rbs_option = rbs_options[i]
    print(f"RBSOption {i+1}:")
    print(f"  Gene Name: {rbs_option.gene_name}")
    print(f"  5' UTR: {rbs_option.utr}")
    print(f"  CDS: {rbs_option.cds}")
    print(f"  First 6 AAs: {rbs_option.first_six_aas}")
    print("-" * 40)
"""
"""# Implementing run

The run method needs to iterate through the list of RBSOption stored in the class variables and pick one.  That choice should be based on 3 criteria:

*  The exclusion of the RBS from an 'ignores' list
*  The absense (or reduction) of secondary structure occlusion between the RBS and the input CDS
*  The similarity of the input peptide to the RBS source gene's peptide

This is a multi-objective optimization problem.  Your algorithm must take all 3 things into account in picking the best option, but how you achieve that is up to you.

There are 4 clear steps to the development process -- exclusion of rbs, looking for secondary structure, comparing peptides, and the fourth would be putting all these together in one run method. You should break up the chat accordingly.  For each part of it, discuss what you are trying to accomplish to make sure you have a mutual undestanding of the goal, and then have it write code, debug, repeat.

In addition to the Translate function, you will need the CalcEditDistance and HairpinCounter functions, provided below. HairpinCounter will be used to determine whether an RBS-CDS combination forms a hairpin structure that blocks the Shine-Dalgarno sequence. CalcEditDistance implements the Smith-Waterman algorithm to compare the first six amino acids of the input CDS' peptide to those of the source gene from the RBSOption. This adds an additional layer of evaluation, taking into account not just the RNA sequence but also the peptide sequence. Since both RNA and peptide sequences are involved in the initiation complex, prioritizing RBS-CDS pairs with similar start sequences increases the likelihood of their compatibility.
"""

def calculate_edit_distance(s1, s2):
    """
    Compute the edit distance between two strings using a dynamic programming approach based on the Smith-Waterman algorithm for local alignment.

    Parameters:
        s1 (str): The first string to compare.
        s2 (str): The second string to compare.

    Returns:
        int: The edit distance between the two strings, defined as the minimum number of edits (insertions, deletions, or substitutions) required to transform one string into the other.
    """
    s1_len = len(s1)
    s2_len = len(s2)
    dist = [[0] * (s2_len + 1) for _ in range(s1_len + 1)]

    # Initialize distances for transformations involving empty strings
    for i in range(s1_len + 1):
        dist[i][0] = i
    for j in range(s2_len + 1):
        dist[0][j] = j

    # Compute distances
    for i in range(1, s1_len + 1):
        for j in range(1, s2_len + 1):
            if s1[i - 1] == s2[j - 1]:
                dist[i][j] = dist[i - 1][j - 1]
            else:
                dist[i][j] = 1 + min(dist[i - 1][j], dist[i][j - 1], dist[i - 1][j - 1])

    return dist[s1_len][s2_len]
"""
# Example usage
distance1 = calculate_edit_distance("AACAAGATAT", "AACATGATAT")
print("Edit distance 1:", distance1)

distance2 = calculate_edit_distance("AACAAGTTAT", "ATCAAGTTCT")
print("Edit distance 2:", distance2)
"""

def hairpin_counter(sequence, min_stem=3, min_loop=4, max_loop=9):
    """
    Counts the number of potential hairpin structures in a DNA sequence. Hairpins are common secondary structures
    in nucleic acids where a sequence of nucleotides can fold back on itself to form a double-stranded stem with a single-stranded loop.

    The algorithm searches for regions within the sequence where a segment can base-pair with its reverse complement separated by a loop.
    This function scans for such occurrences by examining every possible substring as a potential stem and ensuring the intervening
    sequence, which would form the loop, meets the specified length requirements.

    Parameters:
        sequence (str): The DNA sequence to analyze.
        min_stem (int): Minimum number of bases in the stem for stable hairpin. The stem must be able to form at least this many
                        complementary base pairs to be considered.
        min_loop (int): Minimum number of bases in the loop. This prevents the formation of overly tight hairpins which may not be biologically relevant.
        max_loop (int): Maximum number of bases in the loop. This constrains the loop to a realistic size, preventing unlikely structures.

    Returns:
        int: The count of potential hairpin structures detected, indicating regions where secondary structure formation might inhibit biological processes like transcription or translation.

    This method does not account for the thermodynamic stability of the predicted hairpins, focusing solely on their potential for formation based on sequence complementarity and specified geometrical constraints.
    """
    count = 0
    seq_len = len(sequence)

    # Iterate through each base to consider it as a start of a stem
    for i in range(seq_len):
        # Only consider end points that would fit within the loop constraints
        for j in range(i + min_stem + min_loop, min(i + min_stem + max_loop + 1, seq_len)):
            stem1 = sequence[i:i+min_stem]
            stem2 = sequence[j:j+min_stem]

            # Check if the stems are complementary (reverse complement match)
            stem2_rc = ''.join(['ATCG'['TAGC'.index(n)] for n in stem2[::-1]])

            if stem1 == stem2_rc:
                count += 1

    return count

# Example usage
# sequence = "GGCTAATTTAGCCATTAAGGCTAATAGGCTAA"
"""count = hairpin_counter("AAAAAAAAAAAAAAAAAAAAAAAAAAA")
print("Zero hairpins:", count)

count = hairpin_counter("AAAAACCCAAAAAAAAAAGGGAAAAAA")
print("CCC-N10-GGG:", count)

count = hairpin_counter("AAAAACCCAAAAAAAAAGGGAAAAAA")
print("CCC-N9-GGG:", count)

count = hairpin_counter("AAAAACCCCAAAAAAAAGGGGAAAAAA")
print("CCCC-N8-GGGG:", count)

count = hairpin_counter("AAAAACACGAAAAAAAACGTGAAAAAA")
print("CACG-N8-CGTG:", count)

count = hairpin_counter("AAAACCCCCAAAAAAAAGGGGGAAA")
print("CCCCC-N8-GGGGG:", count)

count = hairpin_counter("AAAACCCCCAAAAAAAGGGGGAAA")
print("CCCCC-N7-GGGGG:", count)
"""

"""Notice I expressed these as pure functions instead of function-as-object classes.  This is because their performance would not benefit from caching any data.

Implement the full RBSChooser class, along with API documentation, below:
"""

from typing import Set

class RBSChooser:
    """
    A class to choose the best RBS for a given CDS sequence.
    """

    def __init__(self):
        self.rbs_options = []  # To store RBSOption instances
        self.translator = Translate()
        self.translator.initiate()  # Initialize the translator

    def initiate(self):
        # Iterate over the final_dict and create RBSOption instances
        for locus_tag, data in final_dict.items():
            utr = data["UTR"]
            cds = data["CDS"]
            gene_name = locus_tag  # Using locus_tag as gene_name

            # Translate the CDS to get the first six amino acids
            protein_sequence = self.translator.run(cds[:18])
            first_six_aas = protein_sequence  # Get the first six amino acids

            # Create an RBSOption instance
            rbs_option = RBSOption(utr=utr, cds=cds, gene_name=gene_name, first_six_aas=first_six_aas)

            # Add the RBSOption to the list
            self.rbs_options.append(rbs_option)

    def get_rbs_options(self):
        return self.rbs_options

    def run(self, cds: str, ignores: Set[RBSOption]) -> RBSOption:
        """
        Executes the RBS selection process for the given CDS.

        Parameters:
        - cds (str): The coding sequence to pair with an RBS.
        - ignores (Set[RBSOption]): A set of RBSOption instances to ignore during selection.

        Returns:
        - RBSOption: The selected RBSOption that best pairs with the given CDS.
        """

        score_array = [0] * len(self.rbs_options)
        hairpin_weight = 300

        for i, rbs_option in enumerate(self.rbs_options):
            if rbs_option in ignores:
                score_array[i] = float('inf')  # Assign a high score to ignored options
                continue

            edit_distance = calculate_edit_distance(cds[min(len(cds), 18)], rbs_option.cds[min(len(rbs_option.cds), 18)])
            combined_sequence = rbs_option.utr + cds
            hairpin_count = hairpin_counter(combined_sequence)
            score_array[i] += edit_distance + (hairpin_count * hairpin_weight)

        min_score = min(score_array)
        best_index = score_array.index(min_score)
        return self.rbs_options[best_index]



# Instantiate RBSChooser and initiate
chooser = RBSChooser()
chooser.initiate()

# Test CDS
cds = "ATGGCTAGCAAATACGATTTTACAATATAA"

#chooser.print_edit_distances(cds)
#chooser.print_hairpin_loops(cds)

# Initialize empty ignores set
ignores = set()
"""
# First run, no ignored RBS options
selected_rbs_1 = chooser.run(cds, ignores)
print(f"Selected RBS: {selected_rbs_1}")

# Repeat to confirm determinacy
selected_rbs_2 = chooser.run(cds, ignores)
print(f"Selected RBS: {selected_rbs_2}")

# Add the returned RBSOption to ignores and run again, confirm a different selected RBS
ignores.add(selected_rbs_1)
selected_rbs_3 = chooser.run(cds, ignores)
print(f"Selected RBS after ignoring {selected_rbs_1}: {selected_rbs_3}")
"""
"""# 5' UTR Challenge
**(Required for BioE234 Students, Optional for BioE134 Students)**

Make a version of RBSChooser that more specifically represents the 5' UTR of the source genes.  For this, you will need to figure out the transcriptional start sites, possibly from another data file.  In your run method, prioritize RBSOption with shorter 5' UTRs (a practical consideration).
"""

# TODO (optional):  Write RBSChooser with properly defined 5' UTRs